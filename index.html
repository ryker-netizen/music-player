<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PixelSound 2.0 - Pro Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Silkscreen&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --pixel-blue: #0066ff;
            --pixel-purple: #9900ff;
            --pixel-cyan: #00ffff;
            --pixel-pink: #ff00ff;
            --pixel-green: #00ff88;
            --pixel-yellow: #ffff00;
            --pixel-red: #ff4444;
            --pixel-dark: #0a0a1a;
            --pixel-gray: #333344;
            --pixel-light: #ccccff;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; image-rendering: pixelated; user-select: none; }

        body {
            background: linear-gradient(135deg, var(--pixel-dark) 0%, #1a1a3a 50%, #0d0d2a 100%);
            min-height: 100vh;
            font-family: 'Silkscreen', monospace;
            color: var(--pixel-light);
            padding: 20px;
        }

        .container { max-width: 900px; margin: 0 auto; }

        /* Drag & Drop Overlay style */
        .drag-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 255, 136, 0.2);
            z-index: 1000; display: none;
            justify-content: center; align-items: center;
            font-family: 'Press Start 2P'; font-size: 2rem; color: #fff;
            text-shadow: 4px 4px 0 #000;
            backdrop-filter: blur(5px);
            border: 10px dashed var(--pixel-green);
        }
        .drag-active .drag-overlay { display: flex; }

        /* Header */
        .header { text-align: center; margin-bottom: 30px; position: relative; padding: 20px 0; }
        .title {
            font-family: 'Press Start 2P', cursive; font-size: 2.5rem; color: var(--pixel-cyan);
            text-shadow: 4px 4px 0 var(--pixel-purple), 6px 6px 0 rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }
        .subtitle { color: var(--pixel-green); font-size: 1rem; letter-spacing: 1px; }

        /* Main Player */
        .player-container {
            background: rgba(20, 20, 40, 0.95);
            border: 6px solid var(--pixel-gray);
            box-shadow: 10px 10px 0 #000;
            padding: 20px; margin-bottom: 30px;
            position: relative;
        }

        /* Visualizer */
        .visualizer-wrapper {
            position: relative;
            border: 4px solid var(--pixel-dark);
            height: 200px; margin-bottom: 20px;
            background: #000;
        }
        canvas { display: block; width: 100%; height: 100%; }
        
        .scanline {
            position: absolute; top: 0; left: 0; width: 100%; height: 4px;
            background: rgba(0, 255, 255, 0.3);
            animation: scan 4s linear infinite; pointer-events: none;
        }

        /* Track Info */
        .track-info {
            background: #000; border: 2px solid var(--pixel-gray);
            padding: 15px; margin-bottom: 20px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .track-name { color: var(--pixel-yellow); font-family: 'Press Start 2P'; font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 60%; }
        .track-meta { color: var(--pixel-cyan); font-size: 0.8rem; display: flex; gap: 15px; }

        /* Controls Grid */
        .controls-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px; margin-bottom: 20px;
        }

        .control-group {
            background: rgba(255,255,255,0.05); padding: 15px;
            border: 2px solid var(--pixel-gray);
        }
        .control-title { color: var(--pixel-green); font-size: 0.8rem; margin-bottom: 10px; display: block; }
        
        /* Sliders */
        input[type=range] {
            width: 100%; -webkit-appearance: none; background: transparent;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 10px; background: var(--pixel-dark);
            border: 2px solid var(--pixel-gray);
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 24px; width: 12px;
            background: var(--pixel-cyan); margin-top: -9px;
            border: 2px solid #fff; cursor: pointer;
            box-shadow: 2px 2px 0 #000;
        }

        /* Buttons */
        .btn-row { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-top: 20px; }
        
        .pixel-btn {
            font-family: 'Press Start 2P'; font-size: 0.7rem;
            padding: 15px 5px; border: none; cursor: pointer;
            background: var(--pixel-gray); color: #fff;
            border-bottom: 4px solid #000; border-right: 4px solid #000;
            transition: all 0.1s; position: relative;
            display: flex; flex-direction: column; align-items: center; gap: 8px;
        }
        .pixel-btn:active { transform: translate(2px, 2px); border-width: 0; margin: 2px 0 0 2px; }
        
        .btn-play { background: var(--pixel-green); color: #000; }
        .btn-stop { background: var(--pixel-red); }
        .btn-pixel { background: var(--pixel-purple); }
        .btn-upload { background: var(--pixel-blue); }

        /* Piano */
        .piano-section {
            background: rgba(20,20,40,0.9); border: 6px solid var(--pixel-gray);
            padding: 20px; text-align: center; box-shadow: 10px 10px 0 #000;
        }
        .piano-keys {
            display: inline-flex; position: relative; margin-top: 10px; height: 140px;
        }
        .key {
            border: 2px solid #000; cursor: pointer; position: relative;
            transition: background 0.1s;
        }
        .key-white {
            width: 44px; height: 100%; background: #fff; z-index: 1;
            border-bottom-width: 6px;
        }
        .key-black {
            width: 30px; height: 60%; background: #000; z-index: 2;
            margin: 0 -15px; position: relative;
            border-bottom: 4px solid #333;
        }
        .key.active { background: var(--pixel-pink); transform: translateY(2px); }
        .key-black.active { background: var(--pixel-purple); border-color: transparent; }

        @keyframes scan { 0% { top: 0%; } 100% { top: 100%; } }
        
        @media (max-width: 600px) {
            .btn-row { grid-template-columns: repeat(2, 1fr); }
            .key-white { width: 34px; } .key-black { width: 20px; margin: 0 -10px; }
            .title { font-size: 1.5rem; }
        }
    </style>
</head>
<body class="drop-zone">
    <div class="drag-overlay">DROP FILE HERE</div>

    <div class="container">
        <header class="header">
            <h1 class="title">PixelSound <span style="font-size:0.5em; color:var(--pixel-pink)">v2.0</span></h1>
            <div class="subtitle">DRAG & DROP READY â€¢ REAL BITCRUSHER</div>
        </header>

        <main class="player-container">
            <div class="visualizer-wrapper" id="vizContainer">
                <canvas id="mainCanvas"></canvas>
                <div class="scanline"></div>
            </div>

            <div class="track-info">
                <div class="track-name" id="uiTrackName">NO TAPE INSERTED</div>
                <div class="track-meta">
                    <span id="uiBitDepth">16-BIT</span>
                    <span id="uiSampleRate">44.1KHZ</span>
                </div>
            </div>

            <div class="controls-grid">
                <div class="control-group">
                    <span class="control-title">VOLUME</span>
                    <input type="range" id="volSlider" min="0" max="100" value="80">
                </div>
                <div class="control-group">
                    <span class="control-title">BIT CRUSH (DEPTH)</span>
                    <input type="range" id="bitSlider" min="1" max="16" value="16" step="1">
                </div>
                <div class="control-group">
                    <span class="control-title">DOWNSAMPLE (RATE)</span>
                    <input type="range" id="rateSlider" min="1" max="50" value="1">
                </div>
            </div>

            <div class="btn-row">
                <button class="pixel-btn btn-upload" id="btnUpload"><i class="fas fa-eject"></i> LOAD</button>
                <button class="pixel-btn btn-play" id="btnPlay"><i class="fas fa-play"></i> PLAY</button>
                <button class="pixel-btn btn-stop" id="btnStop"><i class="fas fa-stop"></i> STOP</button>
                <button class="pixel-btn btn-pixel" id="btnMode"><i class="fas fa-eye"></i> MODE</button>
            </div>
        </main>

        <section class="piano-section">
            <div style="font-family: 'Press Start 2P'; color: var(--pixel-green); margin-bottom: 10px;">SYNTH KEYBOARD</div>
            <div class="piano-keys" id="pianoContainer"></div>
        </section>
    </div>

    <input type="file" id="fileInput" accept="audio/*" style="display:none">

    <script>
        /**
         * AUDIO ENGINE
         * Handles Context, Nodes, and Processing logic.
         */
        class AudioEngine {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.source = null;
                this.audioBuffer = null;
                this.isPlaying = false;
                
                // Nodes
                this.gainNode = this.ctx.createGain();
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 2048; // Higher res for better visuals
                
                // Bitcrusher Logic (ScriptProcessor for true sample degradation)
                // Note: AudioWorklet is better for production, but ScriptProcessor fits single-file easier
                this.scriptNode = this.ctx.createScriptProcessor(4096, 1, 1);
                this.bitDepth = 16;
                this.normFactor = 1; // Downsampling factor
                
                this.setupProcessor();
                
                // Connections
                this.scriptNode.connect(this.gainNode);
                this.gainNode.connect(this.analyser);
                this.analyser.connect(this.ctx.destination);
            }

            setupProcessor() {
                this.scriptNode.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    const output = e.outputBuffer.getChannelData(0);
                    
                    const step = Math.pow(0.5, this.bitDepth);
                    
                    for (let i = 0; i < input.length; i++) {
                        // Sample Rate Reduction (Hold effect)
                        // Only update sample every Nth frame
                        let sample = input[i];
                        if (i % this.normFactor !== 0) {
                            sample = input[i - (i % this.normFactor)] || 0;
                        }

                        // Bit Depth Reduction (Quantization)
                        // Math: floor(sample / step) * step
                        if (this.bitDepth < 16) {
                           sample = Math.floor(sample / step) * step; 
                        }

                        output[i] = sample;
                    }
                };
            }

            async loadFile(file) {
                const arrayBuffer = await file.arrayBuffer();
                this.audioBuffer = await this.ctx.decodeAudioData(arrayBuffer);
                return this.audioBuffer;
            }

            play() {
                if (this.ctx.state === 'suspended') this.ctx.resume();
                if (!this.audioBuffer) return;
                
                this.stop(); // Stop previous
                
                this.source = this.ctx.createBufferSource();
                this.source.buffer = this.audioBuffer;
                
                // Chain: Source -> Script(Bitcrush) -> Gain -> Analyser -> Out
                this.source.connect(this.scriptNode);
                
                this.source.start(0);
                this.isPlaying = true;
                
                this.source.onended = () => {
                    this.isPlaying = false;
                    document.dispatchEvent(new Event('audio-ended'));
                };
            }

            stop() {
                if (this.source) {
                    try { this.source.stop(); } catch(e){}
                    this.source.disconnect();
                    this.source = null;
                }
                this.isPlaying = false;
            }

            playTone(freq) {
                if (this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const oscGain = this.ctx.createGain();
                
                // Choose type based on bit depth to match aesthetic
                osc.type = this.bitDepth < 4 ? 'square' : 'sawtooth';
                osc.frequency.value = freq;
                
                oscGain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                oscGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
                
                osc.connect(this.scriptNode); // Pass through effects
                osc.start();
                osc.stop(this.ctx.currentTime + 0.5);
            }

            setVolume(val) {
                this.gainNode.gain.value = val;
            }

            updateEffects(bits, rate) {
                this.bitDepth = bits;
                this.normFactor = Math.floor(rate);
            }
        }

        /**
         * VISUALIZER CLASS
         */
        class Visualizer {
            constructor(canvasId, analyser) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.analyser = analyser;
                this.mode = 0; // 0: Spectrum, 1: Wave
                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                this.canvas.width = this.canvas.parentElement.offsetWidth;
                this.canvas.height = this.canvas.parentElement.offsetHeight;
            }

            toggleMode() {
                this.mode = (this.mode + 1) % 2;
            }

            draw() {
                requestAnimationFrame(() => this.draw());
                
                const w = this.canvas.width;
                const h = this.canvas.height;
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, w, h);

                if (this.mode === 0) {
                    // Spectrum
                    this.analyser.getByteFrequencyData(dataArray);
                    const barWidth = (w / bufferLength) * 2.5;
                    let x = 0;

                    for(let i = 0; i < bufferLength; i++) {
                        let barHeight = dataArray[i] / 255 * h;
                        
                        // Pixelated coloring
                        const hue = i + (Date.now() / 20);
                        this.ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                        
                        // Draw blocky
                        const blocks = Math.floor(barHeight / 10);
                        for(let j=0; j<blocks; j++) {
                            this.ctx.fillRect(x, h - (j * 12), barWidth, 10);
                        }
                        x += barWidth + 2;
                    }
                } else {
                    // Waveform
                    this.analyser.getByteTimeDomainData(dataArray);
                    this.ctx.lineWidth = 4;
                    this.ctx.strokeStyle = '#00ff88';
                    this.ctx.beginPath();
                    
                    const sliceWidth = w * 1.0 / bufferLength;
                    let x = 0;
                    
                    for(let i = 0; i < bufferLength; i++) {
                        const v = dataArray[i] / 128.0;
                        const y = v * h / 2;
                        
                        if(i === 0) this.ctx.moveTo(x, y);
                        else this.ctx.lineTo(x, y);
                        
                        x += sliceWidth;
                    }
                    this.ctx.stroke();
                }
            }
        }

         * UI MANAGER & INITIALIZATION
         */
        const audio = new AudioEngine();
        const viz = new Visualizer('mainCanvas', audio.analyser);
        viz.draw();

        // Elements
        const fileInput = document.getElementById('fileInput');
        const trackName = document.getElementById('uiTrackName');
                // --- Event Listeners ---

        // File Loading
        document.getElementById('btnUpload').onclick = () => fileInput.click();
        
        fileInput.onchange = async (e) => {
            if(e.target.files[0]) handleFile(e.target.files[0]);
        };

        // Drag & Drop
        const body = document.body;
        ['dragenter', 'dragover'].forEach(eventName => {
            body.addEventListener(eventName, (e) => {
                e.preventDefault();
                body.classList.add('drag-active');
            });
        });

        ['dragleave', 'drop'].forEach(eventName => {
            body.addEventListener(eventName, (e) => {
                e.preventDefault();
                body.classList.remove('drag-active');
            });
        });

        body.addEventListener('drop', (e) => {
            const dt = e.dataTransfer;
            const files = dt.files;
            if (files[0] && files[0].type.startsWith('audio')) {
                handleFile(files[0]);
            }
        });

        async function handleFile(file) {
            trackName.textContent = "LOADING...";
            try {
                await audio.loadFile(file);
                trackName.textContent = file.name.toUpperCase();
                document.getElementById('btnPlay').click(); // Auto play
            } catch (err) {
                trackName.textContent = "ERROR LOADING";
                console.error(err);
            }
        }

        // Playback Controls
        document.getElementById('btnPlay').onclick = () => {
            audio.play();
            updateStats();
        };
        document.getElementById('btnStop').onclick = () => audio.stop();
        document.getElementById('btnMode').onclick = () => viz.toggleMode();

        // Sliders
        const volSlider = document.getElementById('volSlider');
        const bitSlider = document.getElementById('bitSlider');
        const rateSlider = document.getElementById('rateSlider');

        function updateParams() {
            const vol = volSlider.value / 100;
            const bits = parseInt(bitSlider.value);
            const rate = parseInt(rateSlider.value);
            
            audio.setVolume(vol);
            audio.updateEffects(bits, rate);
            updateStats();
        }

        [volSlider, bitSlider, rateSlider].forEach(el => {
            el.addEventListener('input', updateParams);
        });

        function updateStats() {
            document.getElementById('uiBitDepth').textContent = `${bitSlider.value}-BIT`;
            // Calculate effective Hz roughly
            const effectiveHz = Math.floor(44100 / rateSlider.value);
            document.getElementById('uiSampleRate').textContent = `${effectiveHz}HZ`;
        }

        // Piano Generator
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const pianoContainer = document.getElementById('pianoContainer');
        
        // Generate 1.5 octaves starting from C4
        for(let i=0; i<20; i++) {
            const noteIndex = i % 12;
            const octave = 4 + Math.floor(i / 12);
            const isBlack = notes[noteIndex].includes('#');
            const noteName = notes[noteIndex];
            
            const key = document.createElement('div');
            key.className = `key key-${isBlack ? 'black' : 'white'}`;
            
            // Calculate Frequency: f = 440 * 2^((n-69)/12)
            // A4 is index 69 (MIDI). Our loop starts C4 (MIDI 60)
            const midi = 60 + i;
            const freq = 440 * Math.pow(2, (midi - 69) / 12);
            
            key.onmousedown = () => {
                key.classList.add('active');
                audio.playTone(freq);
            };
            key.onmouseup = () => key.classList.remove('active');
            key.onmouseleave = () => key.classList.remove('active');
            
            pianoContainer.appendChild(key);
        }
    </script>
</body>
</html>
